#pragma kernel CSMain
#pragma kernel CSClear
#pragma target 5.0

struct Point
{
    float3 pos;
    int color;
};

uniform RWStructuredBuffer<Point> pointBuffer;

uniform float4x4 mvp_mat_left;
uniform float4x4 mvp_mat_right;

uniform int custom_rt_res_x;
uniform int custom_rt_res_y;

uniform RWStructuredBuffer<uint> custom_rt_left;
uniform RWStructuredBuffer<uint> custom_rt_right;


uniform float left_near_clip_plane;
uniform float left_far_clip_plane;
uniform float right_near_clip_plane;
uniform float right_far_clip_plane;

void draw_point(Point p, inout RWStructuredBuffer<uint> _texture, float4x4 mat, float near, float far);

[numthreads(8, 8, 1)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
    int idx = id.y * custom_rt_res_x + id.x;
    custom_rt_left[idx] = 255 << 24;
    custom_rt_right[idx] = 255 << 24;
}

[numthreads(16,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    draw_point(pointBuffer[id.x], custom_rt_left, mvp_mat_left, left_near_clip_plane, left_far_clip_plane);
    draw_point(pointBuffer[id.x], custom_rt_right, mvp_mat_right, right_near_clip_plane, right_far_clip_plane);
}

// d is between -1 to 1 non linear
// https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer/6657284#6657284
float linearize_depth(float d, float near, float far)
{
    float normalized_dist = 2.0 * near * far / (far + near - d * (far - near));
    return (normalized_dist - near) / (far - near);
}

void draw_point(Point p, inout RWStructuredBuffer<uint> _custom_rt, float4x4 mat, float near, float far)
{
    float4 proj = mul(mat, float4(p.pos, 1));
    float3 pos = proj.xyz / proj.w;
    bool clipped = !((-1 <= pos.x && pos.x <= 1) && (-1 <= pos.y && pos.y <= 1) && (-1 <= pos.z && pos.z <= 1));
    
    if (!clipped)
    {
        // how to support points with arbitrary size?
        int rt_x = int(((pos.x + 1) / 2) * custom_rt_res_x);
        int rt_y = int(((pos.y + 1) / 2) * custom_rt_res_y);
        int p_depth = int(linearize_depth(pos.z, near, far) * 255); // saved in range 0 to 255, should be linearlized
        
        int idx = rt_y * custom_rt_res_x + rt_x;
                
        uint value = p.color; // first 3 bytes filed with color information
        value = value | (p_depth << 24); // last byte contains depth information
        
        InterlockedMin(_custom_rt[idx], value); // depth decides if its saved to texture
    }
}